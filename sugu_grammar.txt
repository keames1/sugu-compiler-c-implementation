{*
  The entire grammar of the sugu programming language. Comments are ommitted from the syntax because they
  aren't processed by the parser at all. They're discarded by the lexer right out ot the gate.
  
  This is a multiline comment, and a single line comment begins in a hash symbol. # This is also a comment.
*}

Program        : Imports?, (ImplicitMain | ExplicitMain)?,
                  (Initialization | GlobalConstDeclaration | Nonruntime | Function | Enum | Struct)*

Imports        : (Import | ('namespace', Identifier, ':', '\n', Import+, '\n', '\n')) +

Import         : 'import', Identifier, ('::', Identifier) ?, '\n'

ImplicitMain   : ((Statement | '|'), ('\n' | ';'))*

ExplicitMain   : 'fun', 'main', 'i32', '(', (Identifier, 'List')?, ')', ':', '\n',
                  StmtBlock

# Nonruntimes are executed during compilation and can compute the values of constants declared available
# using the .available keyword.

Nonruntime     : '.nonruntime', '\n',
                  (Statement | Function | Struct | Enum | AvailableStmt | UnavailableStmt | '|') *,
                  '\n', '.end'

AvailableStmt  : '.available', (ArgList | 'any')

UnavailableStmt: '.unavailable' (ArgList | 'all')

Function       : 'fun', Identifier, (TypeKeyword | 'noreturn'),
                 '(', ('impl', Identifier, TypeKeyword)?, ParamList?, ')', ':', '\n',
                    StmtBlock
               : ErrFunc

# Enums can also inherit from other enums. This defaults
# the first enumerand to superEnum.largerstEnumerand + 1.
# Enums can inherit from only one other enum and the values
# of the enumerands in the type hierarchy cannot conflict.

Enum           : 'enum', Identifier, ( '(', Identifier, ')' )?, ':', '\n',
                 ((Identifier | EnumerandAssign), ',')*, (Identifier | EnumerandAssign), ','?,
                 (('\n', '\n') | '\')

EnumerandAssign: Identifier, '=', Expr

Struct         : 'struct', Identifier, ( '(', Identifier?, (',' Identifier, ','?)* ')' )?, ':', '\n',
                  (FieldDeclaration | ConstDeclaration)*, ('\n', '\n') | '\'

# The compiler can populate a structs fields with default values when it allocates the struct.

FieldDeclaration : 'field', Identifier, TypeKeyword, ('=', Expr), '\n' | ';'

GlobalConstDeclaration : 'global', ConstDeclaration

ConstDeclaration : 'const', Initialization

{*
  A function prefixed with a .error statement is called when an error is raised. It either handles the error
  or it leaves with a status of stdlib::PANIC.
*}

ErrFunc        : '.error', ('$', Identifier | TypeKeyword), '\n', Function


Statement      : Expr, ('\n' | ';')
               : Initialization
               : Assign
               : If_stmt
               : Elif_stmt
               : Else_stmt
               : Switch_stmt
               : While_stmt
               : For_stmt
               : Isol_stmt          # Used to limit the scope of variables declared inside it.
               : With_stmt
               : Break_stmt
               : Continue_stmt
               : Return_stmt
               : Raise_stmt
               : Leave_stmt         # Exit the program without returning to main with a specified exit status.

If_stmt        : 'if', expr, ':', '\n',
                 StmtBlock

Elif_stmt      : 'elif', expr, ':', '\n'
                 StmtBlock

Else_stmt      : 'else', ':', '\n'
                 StmtBlock

Switch_stmt    : 'switch', expr, ':', '\n'
                   Case_stmtBlock *,
                 'case', 'default', ':', '\n'
                   StmtBlock

Case_stmtBlock : 'case', Expr, ':', '\n'
                   StmtBlock

While_stmt     : 'while', 'post'?, expr, ':', '\n'
                   StmtBlock

For_stmt       : 'for', Initialization | Assign, 'in', '[', Expr, '..', Expr, ']', ':', '\n'
                   StmtBlock

               : 'for', Initialization | Assign, 'in',
                 (Identifier | StringLiteral | ArrLiteral | FunCall | MemFieldRef), ':', '\n'
                   StmtBlock

               : 'for', Initialization | Assign, ';', Expr, ';', Assign, ':', '\n'
                   StmtBlock

Isol_stmt      : 'isolate', (('using', Identifier | MemFieldRef)* | ('using', 'any'))?, ':', '\n'
                   StmtBlock

with_stmt      : 'with' Expr 'as' Identifier, ':', '\n'
                   StmtBlock

Break_stmt     : 'break', '\n' | ';'

Contunue_stmt  : 'continue', '\n' | ';'

Return_stmt    : 'return', Expr?, '\n' | ';'

Raise_stmt     : 'raise', Expr, '\n' | ';'

Leave_stmt     : 'leave', Expr, '\n' | ';'

StmtBlock      : (Statement | '|')*, ('\n', '\n') | '\'

# There is no variable declaration because all variables in sugu must be initialized to prevent garbage
# from getting into the program.

Initialization : Identifier, ( TypeKeyword | DeclaredType ), '=', expr, ('\n' | ';')

DeclaredType   : '$', Identifier

Assign         : (Identifier | MemFieldRef), ('=' | InPlaceArrithOperator), expr, ('\n' | ';')

# The in place arrithmetic only works with some of the operators. No keyword operators, no unary operators.

InPlaceArrithOperator : InPlaceArrSubset, <NO_SEPERATOR> '='

InPlaceArrSubset : '+' | '-' | '**' | '*' | '//' | '/' | '%' | '^' | '&' | '|' | '>>' | '<<'

Expr           : Expr, MainOperator, Expr
               : MainOperator, Expr
               : Identifier | MemFieldRef, ('<+' | '<-')
               : Expr, 'if', Expr, ('elif', expr, ':', expr)?, 'else', Expr
               : Atom | FunCall | ParenExpr

ParenExpr      : '(', expr, ')'

# These are ordered by token precidence (Excluding atoms and function calls). +, -, and * are duplicated,
# signifying their precidence as both unary and binary operators. \ is the indexing operator.
# It's behavior, not syntax but unary + will be an absolute value operator. (I think this will be more useful.)
# <+ and <- are in place increment and decrement respectively (Postfix operators).

MainOperator   : 'not'| '~' | '$' | '+' | '-' | '&' | '*'
               : 'and' | 'or' | '==' | '!=' | '>=' | '<=' | '<' | '>'
               : '**' | '*' | '/' | '//' | '%' | '+' | '-'
               : '(', TypeKeyword, ')'

FunCall        : Identifier, '(', ArgsList? ')'

ArgsList       : (Expr, ',') *, Expr, ','?
               : (Expr, ',') *, '*', Identifier, ','?

Atom           : Identifier | MemFieldRef | IntegerLiteral | FloatLiteral
               : CharLiteral | StringLiteral | ArrayLiteral

MemFieldRef    : (Identifier, '.') +, Identifier

Identifier     : ('a' - 'z' | '_') +, ('a' - 'z' | '_' | '0' - '9') *

IntegerLiteral : (ImplicitDecimal | ExplicitDecimal | Hexadecimal | Binary), TypeKeyword?

ImplicitDecimal: ('0' - '9'), ('0' - '9' | '_') *

ExplicitDecimal: ('0d' | '0D'), ('0' - '9'), ('0' - '9' | '_') *

Hexadecimal    : ('0x' | '0X'), ('0' - '9' | 'a' - 'f' | 'A' - 'F' | '_') *

Binary         : ('0b' | '0B'), ('0' | '1' | '_')

# Floats are only supported on decimal as of now.

FloatLiteral   : ('0d' | '0D')?, ('0' - '9'), ('0' - '9' | '_') * '.', ('0' - '9' | '_') +

# It says StringBody for convenience reasons. If the string evaluates to length greater than 1 in a character
# literal, the compiler will yell and scream.

CharLiteral    : '\'', StringBody, '\''

StringLiteral  : '"', StringBody, '"'

ArrayLiteral   : '[', (Expr, ',') *, Expr, ','?, ']', TypeKeyword?

TypeKeyword    : 'i8' | 'i16' | 'i32' | 'i64' | 'iexp' | 'u8' | 'u16' | 'u32' | 'u64' | 'f32' | 'f64'
               : 'fexp' | 'char' | 'bool' | ('ref', TypeKeyword) | ('ref', '$', Identifier) | 'String' | 'str'

# ! means anything other than the characters in its operand. {An exact number}

StringBody     : ( !('"' | '\')*, ('\"' | '\n' | '\N' | '\t' | '\T', | '\\' | ('\{', Expr, '}')
                   ('\x', ('0' - '9' | 'A' - 'F' | 'a' - 'f') {2}))
                 )
